<meta charset="UTF-8"/>

<!--
///////////////////////////////////////////////////////////////////////////////////
//                     Copyright (C) 2021 Dr Robert P. Wolf                      //
//                                                                               //
// Permission is hereby granted, free of charge, to any person obtaining a copy  //
// of this software and associated documentation files (the "Software"), to deal //
// in the Software without restriction, including without limitation the rights  //
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell     //
// copies of the Software, and to permit persons to whom the Software is         //
// furnished to do so, subject to the following conditions:                      //
//                                                                               //
// The above copyright notice and this permission notice shall be included in    //
// all copies or substantial portions of the Software.                           //
//                                                                               //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   //
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, //
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN     //
// THE SOFTWARE.                                                                 //
///////////////////////////////////////////////////////////////////////////////////

-->

<html>


<head>
	<link rel="icon" href="../../h.ico"/>
	<title>Navitimer Cosmonaute</title>
</head>

<body style="margin: 0px; background-size: cover;" onbeforeunload="javascript: localStorage . setItem ('Navitimer', JSON . stringify (Status));">

<style>
@font-face
{
font-family: tx;
src: url('TERMINAT.TTF') format('truetype');
}
</style>

<!--
WEB SAFE FONTS:
Arial (sans-serif)
Verdana (sans-serif)
Helvetica (sans-serif)
Tahoma (sans-serif)
Trebuchet MS (sans-serif)
Times New Roman (serif)
Georgia (serif)
Garamond (serif)
Courier New (monospace)
Brush Script MT (cursive)
-->

<canvas id="Navitimer" width="1200" height="600"
	onmousedown="javascript: MouseDown (event);" onmouseup="javascript: MouseUp (event);"
	onmousemove="javascript: MouseMove (event);" onmouseleave="javascript: MouseUp (event);"
	onwheel="javascript: Wheel (event);" oncontextmenu="javascript: event . preventDefault ();"
/>

<script type="text/javascript">

var BreitlingLogo = new Image (); BreitlingLogo . src = 'BreitlingLogoOnly.png';
var AtariLogo = new Image (); AtariLogo . src = 'Atari Logo.png';

var Makers = {
	Breitling: {
		BackgroundImage: 'travel.jpg',
		// BackgroundColour: 'black',
		MonitorColour: 'blue', Monitor: '14px georgia', MonitorStep: 18,
		Logo: BreitlingLogo, LogoScaling: 1 / 560, LogoName: 'COSMONAUTE', LogoYear: 1962,
		PushpieceColour: 'silver',
		BezelRadius: 0.48,
		BezelRim: 0.44,
		BezelNumbers: 0.4,
		BezelColour: 'white', BezelMarkings: 'black', BezelAlt: 'red',
		BezelRimColour: 'silver', BezelRimLineWidth: 4, BezelRimRingColour: 'gray',
		BezelCorrugatedLineColour: 'gray',
		StatorTop: 0.37,
		StatorBottom: 0.32,
		DateDisplayBackground: 'white',
		DateDisplayColour: 'maroon',
		MinuteConversionLine: 0.31,
		Converters: 0.28,
		NumberSize1: 0.036,
		NumberSize2: 0.026,
		HoursSize: 0.06,
		HoursRadius: 0.215,
		Spring: 129600000, SpringStep: 1800000, SpringMarker: 'blue',
		TotalizerRadius: 0.172,
		TotalizerBezel: 0.09,
		TotalizerStator: 0.075,
		TotalizerR1: 0.086,
		TotalizerR2: 0.079,
		TotalizerR3: 0.075,
		TotalizerArrow1: 0.006,
		TotalizerArrow2: 0.004,
		TotalizerArrow3: 0.006,
		TotalizerArrow4: 0.01,
		TotalizerArrow5: 0.02,
		TotalizerArrow6: 0.035,
		TotalizerArrow7: 0.06,
		TotalizerNumbers: 0.05,
		TotalizerNumbersH: 0.056,
		TotalizerBezelColour: 'white',
		TotalizerRimColour: 'black',
		TotalizerStatorColour: 'black',
		TotalizerCyferblatColour: 'silver',
		TotalizerMarkingsColour: 'black',
		TotalizerArrowColour: 'white',
		TotalizerArrowEndColour: 'white',
		TotalizerArrowBorderColour: 'black',
		TotalizerArrowBorderWidth: 0.2,
		PinColour: 'gray'
	},
	BreitlingWhiteSteel: {
		BackgroundImage: 'hubble.jpg',
		//BackgroundColour: 'black',
		Font: 'tx', FontSize: 0.6,
		MonitorColour: 'lime', Monitor: '14px georgia', MonitorStep: 18,
		Logo: BreitlingLogo, LogoScaling: 1 / 560, LogoName: 'CHRONOMETRE', LogoYear: 'AUTOMATIC', ModelName: ' ',
		PushpieceColour: 'silver',
		BezelRadius: 0.48,
		BezelRim: 0.44,
		BezelNumbers: 0.4,
		BezelColour: 'white', BezelMarkings: 'black', BezelAlt: 'red',
		BezelRimColour: 'white', BezelRimLineWidth: 4, BezelRimRingColour: 'silver',
		BezelCorrugatedLineColour: 'silver',
		StatorTop: 0.37,
		StatorBottom: 0.32,
		StatorColour: 'black',
		StatorBackgroundColour: 'white',
		MinuteConversionLine: 0.31,
		Converters: 0.28,
		ConvertersColour: 'black',
		ConvertersBackgroundColour: 'white',
		DateDisplayColour: 'black',
		DateDisplayBackground: 'white',
		DateDisplayBorderColour: 'silver',
		CyferblatColour: 'black',
		MinuteConversionLineWidth: 1,
		NumberSize1: 0.036,
		NumberSize2: 0.026,
		StrokeNumbers: 'black',
		FillNumbers: 'white',
		HoursSize: 0.06,
		HoursRadius: 0.215,
		HandLining: 'white',
		HandStroke: 'silver',
		HandBackground: 'silver',
		Spring: 129600000, SpringStep: 1800000, SpringMarker: 'lime',
		TotalizerRadius: -0.172,
		TotalizerBezel: 0.09,
		TotalizerStator: 0.075,
		TotalizerR1: 0.086,
		TotalizerR2: 0.079,
		TotalizerR3: 0.075,
		TotalizerArrow1: 0.006,
		TotalizerArrow2: 0.004,
		TotalizerArrow3: 0.006,
		TotalizerArrow4: 0.01,
		TotalizerArrow5: 0.02,
		TotalizerArrow6: 0.035,
		TotalizerArrow7: 0.06,
		TotalizerNumbers: 0.05,
		TotalizerNumbersH: 0.056,
		TotalizerBezelColour: 'black',
		//TotalizerRimColour: 'red',
		TotalizerStatorColour: 'black',
		TotalizerCyferblatColour: 'black',
		TotalizerMarkingsColour: 'white',
		TotalizerArrowColour: 'silver',
		TotalizerArrowEndColour: 'silver',
		TotalizerArrowBorderColour: 'black',
		TotalizerArrowBorderWidth: 0.2,
		PinColour: 'navy'
	},
	BreitlingNavy: {
		BackgroundImage: 'carrier.jpg',
		//BackgroundColour: 'black',
		MonitorColour: 'green', Monitor: '14px georgia', MonitorStep: 18,
		Logo: BreitlingLogo, LogoScaling: 1 / 560, LogoName: 'COSMONAUTE', LogoYear: '', ModelName: ' ',
		PushpieceColour: 'silver',
		BezelRadius: 0.48,
		BezelRim: 0.44,
		BezelNumbers: 0.4,
		BezelColour: '#fffdd0', BezelMarkings: 'black', BezelAlt: 'red',
		BezelRimColour: 'white', BezelRimLineWidth: 4, BezelRimRingColour: 'silver',
		BezelCorrugatedLineColour: 'silver',
		StatorTop: 0.37,
		StatorBottom: 0.32,
		StatorColour: 'white',
		StatorBackgroundColour: 'navy',
		MinuteConversionLine: 0.31,
		Converters: 0.28,
		ConvertersColour: 'white',
		ConvertersBackgroundColour: 'white',
		DateDisplayColour: 'black',
		DateDisplayBackground: '#fffdd0',
		DateDisplayBorderColour: 'silver',
		CyferblatColour: 'white',
		MinuteConversionLineWidth: 1,
		NumberSize1: 0.036,
		NumberSize2: 0.026,
		StrokeNumbers: 'white',
		FillNumbers: 'gold',
		HoursSize: 0.06,
		HoursRadius: 0.215,
		HandLining: 'silver',
		HandStroke: 'silver',
		HandBackground: '#fffdd0',
		Spring: 129600000, SpringStep: 1800000, SpringMarker: 'blue',
		TotalizerRadius: 0.172,
		TotalizerBezel: 0.09,
		TotalizerStator: 0.075,
		TotalizerR1: 0.086,
		TotalizerR2: 0.079,
		TotalizerR3: 0.075,
		TotalizerArrow1: 0.006,
		TotalizerArrow2: 0.004,
		TotalizerArrow3: 0.006,
		TotalizerArrow4: 0.01,
		TotalizerArrow5: 0.02,
		TotalizerArrow6: 0.035,
		TotalizerArrow7: 0.06,
		TotalizerNumbers: 0.05,
		TotalizerNumbersH: 0.056,
		TotalizerBezelColour: 'white',
		//TotalizerRimColour: 'red',
		TotalizerStatorColour: '#fffdd0',
		TotalizerCyferblatColour: '#fffdd0',
		TotalizerMarkingsColour: 'black',
		TotalizerArrowColour: 'navy',
		TotalizerArrowEndColour: 'silver',
		TotalizerArrowBorderColour: 'black',
		TotalizerArrowBorderWidth: 0.2,
		TotalizerArrowNoButt: true,
		PinColour: 'gray'
	},
	BreitlingBlackSteel: {
		BackgroundImage: 'galaxy.jpg',
		// BackgroundColour: 'skyblue',
		MonitorColour: 'lime',
		Logo: BreitlingLogo, LogoScaling: 1 / 560, LogoName: 'COSMONAUTE', LogoYear: 1962,
		PushpieceColour: '#333333',
		BezelRadius: 0.48,
		BezelRim: 0.44,
		BezelNumbers: 0.4,
		BezelColour: 'black', BezelMarkings: 'white', BezelAlt: 'red',
		BezelRimColour: 'black', BezelRimRingColour: 'gold',
		BezelCorrugatedLineColour: 'silver',
		StatorTop: 0.37,
		StatorBottom: 0.32,
		MinuteConversionLine: 0.31,
		Converters: 0.28,
		AccurateConversions: true,
		NumberSize1: 0.036,
		NumberSize2: 0.026,
		HoursSize: 0.06,
		HoursRadius: 0.215,
		Spring: 129600000,
		SpringStep: 1800000,
		TotalizerRadius: 0.172,
		TotalizerBezel: 0.09,
		TotalizerStator: 0.075,
		TotalizerR1: 0.086,
		TotalizerR2: 0.079,
		TotalizerR3: 0.075,
		TotalizerArrow1: 0.006,
		TotalizerArrow2: 0.004,
		TotalizerArrow3: 0.006,
		TotalizerArrow4: 0.01,
		TotalizerArrow5: 0.02,
		TotalizerArrow6: 0.035,
		TotalizerArrow7: 0.06,
		TotalizerNumbers: 0.05,
		TotalizerNumbersH: 0.056,
		TotalizerBezelColour: 'black',
		TotalizerRimColour: 'black',
		TotalizerStatorColour: 'black',
		TotalizerCyferblatColour: 'black',
		TotalizerMarkingsColour: 'white',
		TotalizerArrowColour: 'red',
		TotalizerArrowEndColour: 'silver',
		TotalizerArrowBorderColour: 'black',
		TotalizerArrowBorderWidth: 0.2,
		PinColour: 'navy'
	},
	Atari: {
		BackgroundImage: 'Atari ST.png',
		// BackgroundColour: 'black',
		MonitorColour: 'lime',
		Font: 'tx', FontSize: 0.6,
		Logo: AtariLogo, LogoScaling: 1 / 1450, LogoName: '', LogoYear: '', ModelName: 'COSMONAUTE',
		PushpieceColour: 'gray',
		BezelRadius: 0.48,
		BezelRim: 0.44,
		BezelNumbers: 0.4,
		BezelColour: 'white', BezelMarkings: 'black', BezelAlt: 'red',
		BezelRimColour: 'black', BezelRimLineWidth: 4, BezelRimRingColour: 'silver',
		BezelCorrugatedLineColour: 'red',
		StatorTop: 0.37,
		StatorBottom: 0.32,
		StatorBackgroundColour: 'black',
		StatorColour: 'white',
		MinuteConversionLine: 0.31,
		MinuteConversionLineWidth: 1,
		Converters: 0.28,
		ConvertersColour: 'black',
		ConvertersBackground: '#fffdd0',
		CyferblatColour: 'black',
		CyferblatBackground: 'silver',
		AccurateConversions: true,
		NumberSize1: 0.036,
		NumberSize2: 0.026,
		StrokeNumbers: 'red',
		HoursSize: 0.06,
		HoursRadius: 0.215,
		Spring: 129600000, SpringStep: 1800000, SpringMarker: 'lime',
		TotalizerRadius: 0.172,
		TotalizerBezel: 0.09,
		TotalizerStator: 0.075,
		TotalizerR1: 0.086,
		TotalizerR2: 0.079,
		TotalizerR3: 0.075,
		TotalizerR4: 0.084,
		TotalizerArrow1: 0.006,
		TotalizerArrow2: 0.004,
		TotalizerArrow3: 0.006,
		TotalizerArrow4: 0.01,
		TotalizerArrow5: 0.02,
		TotalizerArrow6: 0.035,
		TotalizerArrow7: 0.06,
		TotalizerNumbers: 0.05,
		TotalizerNumbersH: 0.056,
		TotalizerBezelColour: 'black',
		TotalizerRimColour: 'black',
		TotalizerStatorColour: 'black',
		TotalizerCyferblatColour: 'black',
		TotalizerMarkingsColour: 'white',
		TotalizerArrowColour: 'red',
		TotalizerArrowEndColour: 'silver',
		TotalizerArrowBorderColour: 'black',
		TotalizerArrowBorderWidth: 0.2,
		TotalizerArrowNoButt: true,
		PinColour: 'navy'
	}
};

var RandomAdjustment = Math . round (Math . random () * 86400000 - 43200000);
var Status = localStorage . getItem ('Navitimer');
if (Status === null) Status = {
	Maker: 'Breitling',
	Monitor: false,
	Adjustment: RandomAdjustment,
	Chronograph: {From: null, To: null},
	Chronometer: Math . floor (Math . random () * 10000 - 4000),
	Spring: Date . now () + RandomAdjustment,
	PreviousDateNumber: Date . now () - 250 + RandomAdjustment
}; else Status = JSON . parse (Status);

var CirculateMaker = function (delta) {
	var names = Object . keys (Makers);
	var ind = names . indexOf (Status . Maker) + delta;
	if (ind >= names . length) ind = 0; if (ind < 0) ind = names . length - 1;
	Status . Maker = names [ind];
};

Date . prototype . isDST = function () {
	var jan = new Date (this . getFullYear (), 0, 1);
	var jul = new Date (this . getFullYear (), 6, 1);
	var delta = Math . max (jan . getTimezoneOffset (), jul . getTimezoneOffset ());
	return this . getTimezoneOffset () < delta;
}

/*
1. SOFT ADJUST => Adjust time and spring.
2. HARD ADJUST => Adjust time and Chronometer = 0.
3. RESET       => Adjust time and Chronometer = RND.
*/
var SoftAdjust = function (milliseconds) {
	var DateNumber = milliseconds || Date . now ();
	var date = new Date (DateNumber);
	//if (date . isDST ()) date = new Date (DateNumber - 3600000);
	var Day = (Math . floor ((DateNumber - date . getTimezoneOffset () * 60000) / 86400000) % 31) + 1;
	Status . Adjustment = 86400000 * (date . getDate () - Day) + (date . isDST () ? 3600000 : 0);
	Status . Spring = 0;
};
var HardAdjust = function () {SoftAdjust (); Status . Chronometer = 0;};
var ResetAdjust = function () {SoftAdjust (); Status . Chronometer = Math . floor (Math . random () * 10000 - 4000);};

var canvas = document . getElementById ('Navitimer');
var ctx = canvas . getContext ('2d');
var pi2 = Math . PI + Math . PI;

var degree = 0;
var BezelTarget = 0;
var Cursor = 0;
var CursorTarget = 0;
var CursorVisible = false;
var SpringVisible = false;

var SetBezelTarget = function (target) {
	while (target < 0) target += 1; while (target > 1) target -= 1;
	clearInterval (Interval);
	BezelTarget = target;
	if (BezelTarget > degree) {if (BezelTarget - degree > 0.5) BezelTarget -= 1;}
	else {if (degree - BezelTarget > 0.5) BezelTarget += 1;}
	Interval = setInterval (repaint, 25);
};

var SetCursorTarget = function (target) {
	while (target < 0) target += 1; while (target > 1) target -= 1;
	clearInterval (Interval);
	CursorTarget = target;
	if (CursorTarget > Cursor) {if (CursorTarget - Cursor > 0.5) CursorTarget -= 1;}
	else {if (Cursor - CursorTarget > 0.5) CursorTarget += 1;}
	Interval = setInterval (repaint, 25);
};

var point = null;
var point_length = 0;
var point_angle = 0;
var point_cursor_proximity = 0;
var atan = null;
var size = 0;
var ScreenOffset = {x: 0, y: 0, scaling: 1};


var PushpieceA = false;
var PushpieceB = false;
var PushpieceCRotation = 0;
var PushpieceCMode = 'wind'; // calendar time
var PushpieceCDelta = 0;

var SetChronographFrom = false;
var SetChronographTo = false;
var SetChronographFromTo = false;
var PushA = function () {
	PushpieceA = true;
	var Chronograph = Status . Chronograph;
	if (Chronograph . From === null) {SetChronographFrom = true; repaint (); return;}
	if (Chronograph . To === null) SetChronographTo = true;
	else SetChronographFromTo = true;
	repaint ();
};

var PushB = function () {
	PushpieceB = Date . now ();
	var Chronograph = Status . Chronograph;
	if (Chronograph . From !== null && Chronograph . To === null) SetChronographFrom = true;
	else Chronograph . From = Chronograph . To = null;
	repaint ();
};

var PushC = function (e) {
	if (e . button == 0) {
		switch (PushpieceCMode) {
		case 'time': PushpieceCMode = 'calendar'; break;
		case 'calendar': PushpieceCMode = 'wind'; break;
		default: break;
		}
	} else {
		switch (PushpieceCMode) {
		case 'wind': PushpieceCMode = 'calendar'; break;
		case 'calendar': PushpieceCMode = 'time'; break;
		default: break;
		}
	}
};

var MousePoint = function (e) {
	var rect = canvas . getBoundingClientRect ();
	return {
		x: (e . clientX - ScreenOffset . x - rect . left - canvas . width / 2) / ScreenOffset . scaling,
		y: (e . clientY - ScreenOffset . y - rect . top - canvas . height / 2) / ScreenOffset . scaling};
};

var MouseDown = function (e) {
	point = MousePoint (e);
	if (point . x + canvas . width / 2 < 50 && point . y + canvas . height / 2 < 50) {Status . Monitor = ! Status . Monitor; return;}
	if (point . x > size * -0.1 && point . x < size * 0.1 & point . y > size * -0.2 && point . y < size * -0.1) {CirculateMaker (e . button === 0 ? 1 : -1); return;}
	if (Math . abs (point . x) < 5 && Math . abs (point . y) < 5) {HardAdjust (); return;}
	point_length = Math . sqrt (point . x * point . x + point . y * point . y);
	atan = Math . atan2 (point . y, point . x);
	point_angle = atan / pi2 + 0.25;
	while (point_angle < 0) point_angle += 1; while (point_angle > 1) point_angle -= 1;
	point_cursor_proximity = Math . abs (point_angle - Cursor);
	var m = Makers [Status . Maker];
	if (e . button !== 0) {
		if (point_length < m . BezelRim * size && point_length > m . StatorBottom * size) {
			var command = prompt ();
			if (command !== null) {
				command = command . toLowerCase ();
				switch (command) {
				case 'pi': command = Math . PI; break;
				case 'e': command = Math . E; break;
				case 'naut': command = 3.3; break;
				case 'stat': command = m . AccurateConversions ? 3.3 * 1.15078 : 3.8; break;
				case 'km': command = m . AccurateConversions ? 3.3 * 1.852 : 6.1; break;
				case 'mph': command = 6; break;
				default: command = Number (command); break;
				}
				if (isFinite (command)) {
					command *= 10 / 6;
					while (command >= 10) command /= 10; while (command < 1) command *= 10;
					if (point_length < m . StatorTop * size) SetCursorTarget (Math . log10 (command));
					else {
						if (point_cursor_proximity < 0.02 || point_cursor_proximity > 0.98) SetCursorTarget (Math . log10 (command) + degree);
						else SetBezelTarget (1 - Math . log10 (command) + Cursor);
					}
				}
			}
		}
		point = null;
	}
	if (point_length > m . BezelRadius * size && point_length < size * 0.53) {
		var angle = 1 / 6;
		if (Math . abs (point_angle - angle) < 0.012) PushA ();
		if (Math . abs (point_angle - angle - angle) < 0.012) PushB ();
		if (Math . abs (point_angle - 0.25) < 0.025) PushC (e);
	}
	if (Math . abs (point_length - Math . abs (m . TotalizerRadius * size)) < (m . TotalizerBezel * size) && Math . abs (point_angle - 0.75) < 0.06) HiRes ();
	if (Math . abs (point_length - Math . abs (m . TotalizerRadius * size)) < (m . TotalizerBezel * size) && Math . abs (point_angle - 0.25) < 0.06) LoRes ();
};

var MouseUp = function (e) {
	point = null; point_length = 0;
	if (PushpieceB) {
		var delay = Math . floor ((Date . now () - PushpieceB) / 1000);
		if (delay >= 8) ResetAdjust ();
		else if (delay >= 4) SoftAdjust ();
	}
	if (PushpieceA || PushpieceB) {
		PushpieceA = PushpieceB = false;
		repaint ();
	}
};

var MouseMove = function (e) {
	var p = MousePoint (e);
	var length = Math . sqrt (p . x * p . x + p . y * p . y);
	var m = Makers [Status . Maker];
	CursorVisible = (point && point_length < m . BezelRim * size && point_length > m . StatorBottom * size)
		|| (length < m . BezelRim * size && length > m . StatorBottom * size);
	var a = Math . atan2 (p . y, p . x);
	SpringVisible = length > m . BezelRim * size && length < size * 0.53 && Math . abs (a) < 0.15;
	if (! point) return;
	if (point_length < m . BezelRim * size && point_length > m . StatorBottom * size) {
		if (point_length > m . StatorTop * size && point_cursor_proximity > 0.02 && point_cursor_proximity < 0.98) degree += (a - atan) / pi2;
		else if (point_cursor_proximity < 0.02 || point_cursor_proximity > 0.98) Cursor += (a - atan) / pi2;
		while (degree < 0) degree += 1; while (degree > 1) degree -= 1; BezelTarget = degree;
		while (Cursor < 0) Cursor += 1; while (Cursor > 1) Cursor -= 1; CursorTarget = Cursor;
	} else {ScreenOffset . x += e . movementX; ScreenOffset . y += e . movementY;}
	point = p; atan = a;
	repaint ();
};

var SpringDelta = 0;

var Wheel = function (event) {
	var delta = 0;
	if (event . deltaY > 0) delta = -1;
	if (event . deltaY < 0) delta = 1;
	if (! SpringVisible) {if (delta > 0) ScreenOffset . scaling *= 1.0625; else ScreenOffset . scaling /= 1.0625; return;}
	switch (PushpieceCMode) {
	case 'wind': if (delta > 0) SpringDelta = Makers [Status . Maker] . SpringStep * delta; break;
	case 'calendar': PushpieceCDelta = 86400000 * delta; break;
	case 'time': PushpieceCDelta = 60000 * delta; break;
	default: break;
	}
	PushpieceCRotation += delta;
	while (PushpieceCRotation > 2) PushpieceCRotation -= 3; while (PushpieceCRotation < 0) PushpieceCRotation += 3;
	repaint ();
};

var mark = function (position, r1, r2) {
	var angle = Math . log10 (position) * pi2;
	var sin = Math . sin (angle); var cos = - Math . cos (angle);
	ctx . moveTo (r1 * sin, r1 * cos); ctx . lineTo (r2 * sin, r2 * cos);
};

var lmark = function (position, r1, r2) {
	var angle = position * pi2;
	var sin = Math . sin (angle); var cos = - Math . cos (angle);
	ctx . moveTo (r1 * sin, r1 * cos); ctx . lineTo (r2 * sin, r2 * cos);
};

var repaint = function () {
	var maker = Makers [Status . Maker];
	var Chronograph = Status . Chronograph;
	//==== SIMULATION ====
	var CurrentDateNumber = Date . now ();
	var DateNumber = CurrentDateNumber + Status . Adjustment;
	//==== SPRING ================
	if (! Status . Spring) {Status . Spring = DateNumber + maker . Spring;}
	else {
		if (Status . Spring <= DateNumber) {
			Status . Adjustment = Status . Spring - CurrentDateNumber;
			DateNumber = CurrentDateNumber + Status . Adjustment;
		}
	}
	if (SpringDelta) {
		if (Status . Spring < DateNumber) Status . Spring = DateNumber;
		Status . Spring += SpringDelta;
		if (Status . Spring > DateNumber + maker . Spring) Status . Spring = DateNumber + maker . Spring;
		SpringDelta = 0;
	}
	if (SetChronographFrom) {Chronograph . From = DateNumber; SetChronographFrom = false;}
	if (SetChronographTo) {Chronograph . To = DateNumber; SetChronographTo = false;}
	if (SetChronographFromTo) {Chronograph . From += DateNumber - Chronograph . To; Chronograph . To = null; SetChronographFromTo = false;}
	//==== STOP ================
	if (Status . PreviousDateNumber && PushpieceCMode !== 'wind') {
		Status . Adjustment -= DateNumber - Status . PreviousDateNumber - PushpieceCDelta;
		Status . Spring += PushpieceCDelta;
		if (Chronograph . From) Chronograph . From += PushpieceCDelta;
		if (Chronograph . To) Chronograph . To += PushpieceCDelta;
		PushpieceCDelta = 0;
		DateNumber = CurrentDateNumber + Status . Adjustment;
	}
	var date = new Date (DateNumber);
	var offset = date . getTimezoneOffset ();
	var AllDays = Math . floor ((DateNumber - offset * 60000) / 86400000);
	var Day = (AllDays % 31) + 1;
	//if (date . isDST ()) date = new Date (DateNumber - 3600000);
	var ChronometerFraction;
	//==== CHRONOMETER ADJUSTMENT ================
	if (Status . PreviousDateNumber) {
		ChronometerFraction = Status . Chronometer * (DateNumber - Status . PreviousDateNumber) / 86400000;
		Status . Adjustment += ChronometerFraction;
	}
	//================
	Status . PreviousDateNumber = DateNumber;
	if (BezelTarget !== degree) {
		if (Math . abs (BezelTarget - degree) < 0.003125) {
			while (BezelTarget < 0) BezelTarget += 1; while (BezelTarget > 1) BezelTarget -= 1;
			degree = BezelTarget; clearInterval (Interval); Interval = setInterval (repaint, 250);
		} else {if (degree < BezelTarget) degree += 0.003125; else degree -= 0.003125;}
	}
	if (CursorTarget !== Cursor) {
		if (Math . abs (CursorTarget - Cursor) < 0.003125) {
			while (CursorTarget < 0) CursorTarget += 1; while (CursorTarget > 1) CursorTarget -= 1;
			Cursor = CursorTarget; clearInterval (Interval); Interval = setInterval (repaint, 250);
		} else {if (Cursor < CursorTarget) Cursor += 0.003125; else Cursor -= 0.003125;}
	}
	//====================
	canvas . width = window . innerWidth;
	canvas . height = window . innerHeight;
	size = canvas . height;
	var BezelRadius = - maker . BezelRadius * size;
	var BezelDent = BezelRadius / -20;
	var BezelRim = maker . BezelRim * size;
	var StatorTop = maker . StatorTop * size;
	var StatorBottom = - maker . StatorBottom * size;
	var r1 = StatorTop + 1; var r2 = StatorTop * 1.04; var r3 = StatorTop * 1.05; var r4 = StatorTop * 1.06;
	var rm1 = StatorTop; var rm2 = StatorTop * 0.96; var rm3 = StatorTop * 0.95; var rm4 = StatorTop * 0.94;
	var MinuteConversionLine = maker . MinuteConversionLine * size;
	var Converters = - maker . Converters * size;
	var NumberSize1 = maker . NumberSize1 * size;
	var NumberSize2 = maker . NumberSize2 * size;
	var BezelNumber = - maker . BezelNumbers * size;
	var BezelLeft = Math . PI / 2 - 1;
	var BezelRight = Math . PI / 2 + 1;
	var HoursSize = maker . HoursSize * size;
	var HoursRadius = maker . HoursRadius * size;
	if (maker . BackgroundColour) {ctx . fillStyle = maker . BackgroundColour; ctx . fillRect (0, 0, canvas . width, canvas . height);}
	if (maker . BackgroundImage) document . body . style . backgroundImage = `url('${maker . BackgroundImage}')`;
	//==== STATUS ================
	if (Status . Monitor) {
		ctx . fillStyle = maker . MonitorColour;
		if (maker . Monitor) ctx . font = maker . Monitor;
		var Monitor = 10, MonitorStep = 10;
		if (maker . MonitorStep) Monitor = MonitorStep = maker . MonitorStep;
		ctx . fillText (`Current Date: ${new Date (CurrentDateNumber)}`, 10, Monitor); Monitor += MonitorStep;
		ctx . fillText (`Watch Date:   ${date . toString ()}`, 10, Monitor); Monitor += MonitorStep;
		ctx . fillText (`Current Milliseconds: ${CurrentDateNumber}`, 10, Monitor); Monitor += MonitorStep;
		ctx . fillText (`Watch Milliseconds:   ${DateNumber}`, 10, Monitor); Monitor += MonitorStep;
		ctx . fillText (`Total Days: ${AllDays}`, 10, Monitor); Monitor += MonitorStep;
		ctx . fillText (`Days mod 31: ${Day}`, 10, Monitor); Monitor += MonitorStep;
		ctx . fillText (`Adjustment [${Status . Adjustment}] => ${Math . floor (Status . Adjustment / 86400000)} days ${Math . floor (Status . Adjustment / 3600000) % 24} hours ${Math . floor (Status . Adjustment / 60000) % 60} minutes ${((Status . Adjustment / 1000) % 60) .toFixed (3)} seconds`, 10, Monitor); Monitor += MonitorStep;
		ctx . fillText (`Chronograph: [${Chronograph . From} <=> ${Chronograph . To}] ${Chronograph . From === null ? '' :
			Chronograph . To === null ? Math . floor ((DateNumber - Chronograph . From) / 3600000) + ':' + Math . floor (((DateNumber - Chronograph . From) / 60000) % 60) + ':' + (((DateNumber - Chronograph . From) / 1000) % 60) . toFixed (3)
			: Math . floor ((Chronograph . To - Chronograph . From) / 3600000) + ':' + Math . floor (((Chronograph . To - Chronograph . From) / 60000) % 60) + ':' + (((Chronograph . To - Chronograph . From) / 1000) % 60) . toFixed (3)}`,
			10, Monitor); Monitor += MonitorStep;
		if (Status . Chronometer >= 0) ctx . fillText (`Chronometer: [${Status . Chronometer}] => ${Math . floor (Status . Chronometer / 86400000)} days ${Math . floor ((Status . Chronometer / 3600000) % 24)} hours ${Math . floor ((Status . Chronometer / 60000) % 60)} minutes ${((Status . Chronometer / 1000) % 60) . toFixed (3)} seconds per day`, 10, Monitor);
		else ctx . fillText (`Chronometer: [${Status . Chronometer}] => ${Math . ceil (Status . Chronometer / 86400000)} days ${Math . ceil ((Status . Chronometer / 3600000) % 24)} hours ${Math . ceil ((Status . Chronometer / 60000) % 60)} minutes ${((Status . Chronometer / 1000) % 60) . toFixed (3)} seconds per day`, 10, Monitor);
		Monitor += MonitorStep;
		ctx . fillText (`Fraction: ${ChronometerFraction}`, 10, Monitor); Monitor += MonitorStep;
		ctx . fillText (`Spring: ${Math . round (100 * (Status . Spring - DateNumber) / maker . Spring)}% [${Status . Spring - DateNumber}]`, 10, Monitor); Monitor += MonitorStep;
		ctx . fillText (`Spring Timeout: ${new Date (Status . Spring)}`, 10, Monitor); Monitor += MonitorStep;
		ctx . fillText (`Timezone offset: ${offset / 60} hours`, 10, Monitor); Monitor += MonitorStep;
	}
	//=======================
	ctx . save ();
	ctx . textBaseline = 'alphabetic';
	ctx . textAlign = 'center';
	ctx . font = `${NumberSize1 * (maker . FontSize || 1)}px ${maker . Font || 'arial'}`;
	ctx . translate (canvas . width * 0.5 + ScreenOffset . x, canvas . height * 0.5 + ScreenOffset . y);
	ctx . scale (ScreenOffset . scaling, ScreenOffset . scaling);
	//==== PUSHPIECES ======================
	ctx . save ();
		var bw1 = size * 0.07; var bw2 = size * 0.075; var bw3 = size * 0.075; var bw4 = size * 0.04;
		var rw1 = size * 0.5; var rw2 = size * 0.45; var rw3 = size * 0.5; var rw4 = size * 0.51;
		var pub = 0;
		switch (PushpieceCMode) {
		case 'wind': pub = 0; break;
		case 'calendar': pub = size * 0.02; break;
		case 'time': pub = size * 0.04; break;
		default: break;
		}
		rw1 += pub; rw2 += pub; rw3 += pub; rw4 += pub;
		ctx . beginPath ();
		ctx . moveTo (BezelRim, - bw1); ctx . lineTo (rw1, - bw1); ctx . lineTo (rw1, bw1); ctx . lineTo (BezelRim, bw1);
		ctx . lineWidth = 2;
		var colour = maker . PushpieceColour || 'silver';
		var gradient = ctx . createLinearGradient (0, -bw2 / 2, 0, bw2);
		gradient . addColorStop (0, colour);
		gradient . addColorStop (0.5, 'white');
		gradient . addColorStop (1, colour);
		ctx . fillStyle = gradient;
		ctx . fill (); ctx . stroke ();
		ctx . beginPath ();
		ctx . moveTo (rw2, - bw2); ctx . lineTo (rw3, - bw3); ctx . bezierCurveTo (rw4, -bw4, rw4, bw4, rw3, bw3); ctx . lineTo (rw2, bw2); ctx . closePath ();
		ctx . fill ();
		ctx . moveTo (rw3, - bw2); ctx . lineTo (rw3, bw2);
		ctx . strokeStyle = 'black'; ctx . stroke ();

		switch (PushpieceCRotation) {
		case (1):
			ctx . beginPath ();
			ctx . moveTo (rw3, size * -0.0066); ctx . lineTo (rw2, size * -0.0066);
			ctx . moveTo (rw3, size * 0.0133); ctx . lineTo (rw2, size * 0.0133);
			ctx . moveTo (rw3, size * -0.026); ctx . lineTo (rw2, size * -0.026);
			ctx . moveTo (rw3, size * 0.032); ctx . lineTo (rw2, size * 0.032);
			ctx . moveTo (rw3, size * -0.0433); ctx . lineTo (rw2, size * -0.0433);
			ctx . moveTo (rw3, size * 0.0487); ctx . lineTo (rw2, size * 0.0487);
			ctx . moveTo (rw3, size * -0.0587); ctx . lineTo (rw2, size * -0.0587);
			ctx . moveTo (rw3, size * 0.0633); ctx . lineTo (rw2, size * 0.0633);
			ctx . moveTo (rw3, size * -0.07); ctx . lineTo (rw2, size * -0.07);
			ctx . moveTo (rw3, size * 0.0723); ctx . lineTo (rw2, size * 0.0723);
			ctx . lineWidth = 3;
			ctx . strokeStyle = 'black'; ctx . stroke ();
			break;
		case (2):
			ctx . beginPath ();
			ctx . moveTo (rw3, size * 0.0066); ctx . lineTo (rw2, size * 0.0066);
			ctx . moveTo (rw3, size * -0.0133); ctx . lineTo (rw2, size * -0.0133);
			ctx . moveTo (rw3, size * 0.026); ctx . lineTo (rw2, size * 0.026);
			ctx . moveTo (rw3, size * -0.032); ctx . lineTo (rw2, size * -0.032);
			ctx . moveTo (rw3, size * 0.0433); ctx . lineTo (rw2, size * 0.0433);
			ctx . moveTo (rw3, size * -0.0487); ctx . lineTo (rw2, size * -0.0487);
			ctx . moveTo (rw3, size * 0.0587); ctx . lineTo (rw2, size * 0.0587);
			ctx . moveTo (rw3, size * -0.0633); ctx . lineTo (rw2, size * -0.0633);
			ctx . moveTo (rw3, size * 0.07); ctx . lineTo (rw2, size * 0.07);
			ctx . moveTo (rw3, size * -0.0723); ctx . lineTo (rw2, size * -0.0723);
			ctx . lineWidth = 3;
			ctx . strokeStyle = 'black'; ctx . stroke ();
			break;
		default:
			ctx . beginPath ();
			ctx . moveTo (rw3, 0); ctx . lineTo (rw2, 0);
			ctx . moveTo (rw3, size * 0.02); ctx . lineTo (rw2, size * 0.02);
			ctx . moveTo (rw3, size * -0.02); ctx . lineTo (rw2, size * -0.02);
			ctx . moveTo (rw3, size * 0.038); ctx . lineTo (rw2, size * 0.038);
			ctx . moveTo (rw3, size * -0.038); ctx . lineTo (rw2, size * -0.038);
			ctx . moveTo (rw3, size * 0.054); ctx . lineTo (rw2, size * 0.054);
			ctx . moveTo (rw3, size * -0.054); ctx . lineTo (rw2, size * -0.054);
			ctx . moveTo (rw3, size * 0.068); ctx . lineTo (rw2, size * 0.068);
			ctx . moveTo (rw3, size * -0.068); ctx . lineTo (rw2, size * -0.068);
			ctx . lineWidth = 3;
			ctx . strokeStyle = 'black'; ctx . stroke ();
			break;
		}
		if (maker . SpringMarker) ctx . fillStyle = maker . SpringMarker;
		if (SpringVisible) ctx . fillText (`${Math . round (100 * (Status . Spring - DateNumber) / maker . Spring)}%`, size * 0.5, size * -0.1);
	//==============================
	ctx . rotate (pi2 / 12);
		var bw1 = size * 0.03; var bw2 = size * 0.035; var bw3 = size * 0.037; var bw4 = size * 0.02;
		var rw1 = size * 0.5; var rw2 = size * 0.475; var rw3 = size * 0.52; var rw4 = size * 0.53;
		if (PushpieceB) {var pub = size * 0.005; rw2 -= pub; rw3 -= pub; rw4 -= pub;}
		ctx . beginPath ();
		ctx . moveTo (BezelRim, - bw1); ctx . lineTo (rw1, - bw1); ctx . lineTo (rw1, bw1); ctx . lineTo (BezelRim, bw1);
		ctx . lineWidth = 2;
		var colour = maker . PushpieceColour || 'navy';
		var gradient = ctx . createLinearGradient (0, -bw2 / 2, 0, bw2);
		gradient . addColorStop (0, colour);
		gradient . addColorStop (0.5, 'white');
		gradient . addColorStop (1, colour);
		ctx . fillStyle = gradient;
		ctx . fill (); ctx . stroke ();
		ctx . beginPath ();
		ctx . moveTo (rw2, - bw2); ctx . lineTo (rw3, - bw3); ctx . bezierCurveTo (rw4, -bw4, rw4, bw4, rw3, bw3); ctx . lineTo (rw2, bw2); ctx . closePath ();
		ctx . fill (); ctx . stroke ();
	//==============================
	ctx . rotate (pi2 / -6);
		var bw1 = size * 0.03; var bw2 = size * 0.035; var bw3 = size * 0.037; var bw4 = size * 0.02;
		var rw1 = size * 0.5; var rw2 = size * 0.475; var rw3 = size * 0.52; var rw4 = size * 0.53;
		if (PushpieceA) {var pub = size * 0.005; rw2 -= pub; rw3 -= pub; rw4 -= pub;}
		ctx . beginPath ();
		ctx . moveTo (BezelRim, - bw1); ctx . lineTo (rw1, - bw1); ctx . lineTo (rw1, bw1); ctx . lineTo (BezelRim, bw1);
		ctx . lineWidth = 2;
		ctx . fillStyle = gradient;
		ctx . fill (); ctx . stroke ();
		ctx . beginPath ();
		ctx . moveTo (rw2, - bw2); ctx . lineTo (rw3, - bw3); ctx . bezierCurveTo (rw4, -bw4, rw4, bw4, rw3, bw3); ctx . lineTo (rw2, bw2); ctx . closePath ();
		ctx . fill (); ctx . stroke ();
	ctx . restore ();
	//==== BEZEL RIM ======================
	ctx . save ();
	ctx . rotate (degree * pi2);
	ctx . beginPath ();
	for (var ind = 0; ind < 60; ind ++) {
		ctx . arc (0, BezelRadius, BezelDent, BezelRight, BezelLeft, true);
		ctx . rotate (Math . PI / 30);
	}
	ctx . closePath ();
	ctx . fillStyle = maker . BezelRimColour; ctx . fill ();
	if (maker . BezelCorrugatedLineColour) {ctx . strokeStyle = maker . BezelCorrugatedLineColour; ctx . stroke ();}
	ctx . moveTo (StatorTop, 0);
	//ctx . beginPath ();
	//ctx . arc (0, 0, StatorTop, 0, Math . PI * 2);
	//ctx . stroke (); ctx . fillStyle = maker . BezelColour; ctx . fill ();
	ctx . strokeStyle = maker . BezelAlt;
	if (maker . BezelRimLineWidth) ctx . lineWidth = maker . BezelRimLineWidth;
	ctx . beginPath (); ctx . arc (0, 0, BezelRim, 0, Math . PI * 2); ctx . fillStyle = maker . BezelColour; ctx . fill (); ctx . strokeStyle = maker . BezelRimRingColour; ctx . stroke ();
	//ctx . beginPath (); ctx . arc (0, 0, BezelRim + 7, 0, Math . PI * 2); ctx . stroke ();
	//ctx . beginPath (); ctx . arc (0, 0, StatorTop, 0, Math . PI * 2); ctx . stroke ();
	ctx . restore ();
	//==== BEZEL ======================
	ctx . save();
	var shift = Math . log10 (6);
	var position = shift;
	ctx . rotate (- pi2 * (position - degree));
	ctx . beginPath ();
	for (var ind = 1.2; ind < 2.5; ind += 0.1) {
		mark (ind + 0.02, r1, r3);
		mark (ind + 0.04, r1, r3);
		mark (ind + 0.06, r1, r3);
		mark (ind + 0.08, r1, r3);
	}
	for (var ind = 2.5; ind < 6; ind += 0.5) {
		mark (ind + 0.05, r1, r2);
		mark (ind + 0.1, r1, r3);
		mark (ind + 0.15, r1, r2);
		mark (ind + 0.2, r1, r3);
		mark (ind + 0.25, r1, r2);
		mark (ind + 0.3, r1, r3);
		mark (ind + 0.35, r1, r2);
		mark (ind + 0.4, r1, r3);
		mark (ind + 0.45, r1, r2);
	}
	for (var ind = 6; ind < 12; ind += 0.5) {
		mark (ind + 0.1, r1, r3);
		mark (ind + 0.2, r1, r3);
		mark (ind + 0.3, r1, r3);
		mark (ind + 0.4, r1, r3);
	}
	ctx . strokeStyle = maker . BezelMarkings; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 1.2; ind < 2.6; ind += 0.1) mark (ind, r1, r4);
	for (var ind = 3; ind < 6; ind += 0.5) mark (ind, r1, r4);
	for (var ind = 6.5; ind < 12; ind += 0.5) if (ind !== 10) mark (ind, r1, r4);
	ctx . lineWidth = 3; ctx . stroke ();
	ctx . fillStyle = maker . BezelAlt; ctx . fillText ('10', 0, BezelNumber); ctx . fillStyle = maker . BezelMarkings;
	var next = Math . log10 (1.1); ctx . rotate (pi2 * next); ctx . fillText ('11', 0, BezelNumber); position = next;
	next = Math . log10 (1.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('12', 0, BezelNumber); position = next;
	next = Math . log10 (1.3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('13', 0, BezelNumber); position = next;
	next = Math . log10 (1.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('14', 0, BezelNumber); position = next;
	next = Math . log10 (1.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('15', 0, BezelNumber); position = next;
	next = Math . log10 (1.6); ctx . rotate (pi2 * (next - position)); ctx . fillText ('16', 0, BezelNumber); position = next;
	next = Math . log10 (1.7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('17', 0, BezelNumber); position = next;
	next = Math . log10 (1.8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('18', 0, BezelNumber); position = next;
	next = Math . log10 (1.9); ctx . rotate (pi2 * (next - position)); ctx . fillText ('19', 0, BezelNumber); position = next;
	next = Math . log10 (2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('20', 0, BezelNumber); position = next;
	next = Math . log10 (2.1); ctx . rotate (pi2 * (next - position)); ctx . fillText ('21', 0, BezelNumber); position = next;
	next = Math . log10 (2.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('22', 0, BezelNumber); position = next;
	next = Math . log10 (2.3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('23', 0, BezelNumber); position = next;
	next = Math . log10 (2.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('24', 0, BezelNumber); position = next;
	next = Math . log10 (2.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('25', 0, BezelNumber); position = next;
	next = Math . log10 (3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('30', 0, BezelNumber); position = next;
	next = Math . log10 (3.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('35', 0, BezelNumber); position = next;
	next = Math . log10 (4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('40', 0, BezelNumber); position = next;
	next = Math . log10 (4.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('45', 0, BezelNumber); position = next;
	next = Math . log10 (5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('50', 0, BezelNumber); position = next;
	next = Math . log10 (5.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('55', 0, BezelNumber); position = next;
	next = Math . log10 (6); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = maker . BezelAlt; ctx . fillText ('60', 0, BezelNumber); position = next;
	next = Math . log10 (6.5); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = maker . BezelMarkings; ctx . fillText ('65', 0, BezelNumber); position = next;
	next = Math . log10 (7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('70', 0, BezelNumber); position = next;
	next = Math . log10 (7.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('75', 0, BezelNumber); position = next;
	next = Math . log10 (8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('80', 0, BezelNumber); position = next;
	next = Math . log10 (8.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('85', 0, BezelNumber); position = next;
	next = Math . log10 (9); ctx . rotate (pi2 * (next - position)); ctx . fillText ('90', 0, BezelNumber); position = next;
	next = Math . log10 (9.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('95', 0, BezelNumber); position = next;
	ctx . restore ();
	//==== BEZEL RED ARROWS ===================
	var t2 = StatorTop * -1.06; var t3 = StatorTop * -1.1;
	var s6 = size * 0.006;
	ctx . save ();
	ctx . rotate (degree * pi2);
	ctx . beginPath ();
	ctx . moveTo (0, - StatorTop - 1); ctx . lineTo (size * 0.006, BezelNumber * 0.99); ctx . lineTo (size * -0.006, BezelNumber * 0.99); ctx . closePath ();
	ctx . fillStyle = maker . BezelAlt; ctx . fill ();
	ctx . rotate (- pi2 * shift);
	ctx . moveTo (0, - StatorTop - 1); ctx . lineTo (size * 0.006, BezelNumber * 0.99); ctx . lineTo (size * -0.006, BezelNumber * 0.99); ctx . closePath ();
	ctx . fill ();
	ctx . rotate (pi2 * Math . log10 (3.6));
	ctx . moveTo (0, t2); ctx . lineTo (size * 0.006, t3); ctx . lineTo (size * -0.006, t3); ctx . closePath ();
	ctx . fill ();
	ctx . restore ();
	//==== STATOR ======================
	ctx . save ();
	ctx . beginPath (); ctx . arc (0, 0, StatorTop, 0, Math . PI * 2); ctx . fillStyle = maker . StatorBackgroundColour || 'black'; ctx . fill ();
	ctx . rotate (- pi2 * shift);
	ctx . beginPath ();
	for (var ind = 1.2; ind < 2.5; ind += 0.1) {
		mark (ind + 0.02, rm1, rm3);
		mark (ind + 0.04, rm1, rm3);
		mark (ind + 0.06, rm1, rm3);
		mark (ind + 0.08, rm1, rm3);
	}
	for (var ind = 2.5; ind < 6; ind += 0.5) {
		mark (ind + 0.05, rm1, rm2);
		mark (ind + 0.1, rm1, rm3);
		mark (ind + 0.15, rm1, rm2);
		mark (ind + 0.2, rm1, rm3);
		mark (ind + 0.25, rm1, rm2);
		mark (ind + 0.3, rm1, rm3);
		mark (ind + 0.35, rm1, rm2);
		mark (ind + 0.4, rm1, rm3);
		mark (ind + 0.45, rm1, rm2);
	}
	for (var ind = 6; ind < 12; ind += 0.5) {
		if (ind !== 6) mark (ind + 0.1, rm1, rm3);
		mark (ind + 0.2, rm1, rm3);
		mark (ind + 0.3, rm1, rm3);
		mark (ind + 0.4, rm1, rm3);
	}
	mark (6, rm1, rm3);
	ctx . strokeStyle = maker . StatorColour || 'white'; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 1.2; ind < 2.6; ind += 0.1) mark (ind, rm1, rm4);
	for (var ind = 3; ind < 6; ind += 0.5) mark (ind, rm1, rm4);
	for (var ind = 6.5; ind < 12; ind += 0.5) if (ind !== 10) mark (ind, rm1, rm4);
	ctx . lineWidth = 3; ctx . stroke ();
	ctx . beginPath (); ctx . arc (0, 0, MinuteConversionLine, 0, pi2);
	if (maker . ConvertersBackground) {ctx . fillStyle = maker . ConvertersBackground; ctx . fill ();}
	ctx . lineWidth = maker . MinuteConversionLineWidth || 3; ctx . stroke ();
	if (maker . CyferblatBackground) {ctx . beginPath (); ctx . arc (0, 0, Converters * -0.98, 0, Math . PI * 2); ctx . fillStyle = maker . CyferblatBackground; ctx . fill ();}
	ctx . font = `${NumberSize2 * (maker . FontSize || 1)}px ${maker . Font || 'arial'}`;
	ctx . fillStyle = 'red'; ctx . fillText ('10', 0, StatorBottom);
		ctx . fillStyle = maker . ConvertersColour || 'white';ctx . fillText ('1:40', 0, Converters); ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (1.1); ctx . rotate (pi2 * next); ctx . fillText ('11', 0, StatorBottom);
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('1:50', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (1.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('12', 0, StatorBottom);
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('2:00', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (1.3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('13', 0, StatorBottom); position = next;
	next = Math . log10 (1.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('14', 0, StatorBottom); position = next;
	next = Math . log10 (1.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('15', 0, StatorBottom);
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('2:30', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (1.6); ctx . rotate (pi2 * (next - position)); ctx . fillText ('16', 0, StatorBottom); position = next;
	next = Math . log10 (1.7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('17', 0, StatorBottom); position = next;
	next = Math . log10 (1.8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('18', 0, StatorBottom);
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('3:00', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (1.9); ctx . rotate (pi2 * (next - position)); ctx . fillText ('19', 0, StatorBottom); position = next;
	next = Math . log10 (2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('20', 0, StatorBottom); position = next;
	next = Math . log10 (2.1); ctx . rotate (pi2 * (next - position)); ctx . fillText ('21', 0, StatorBottom);
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('3:30', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (2.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('22', 0, StatorBottom); position = next;
	next = Math . log10 (2.3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('23', 0, StatorBottom); position = next;
	next = Math . log10 (2.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('24', 0, StatorBottom);
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('4:00', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (2.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('25', 0, StatorBottom); position = next;
	next = Math . log10 (2.7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('4:30', 0, Converters); position = next;
	next = Math . log10 (3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('30', 0, StatorBottom);
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('5:00', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (3.275); ctx . rotate (pi2 * (next - position)); ctx . fillText ('NAUT.', 0, StatorBottom); position = next;
	next = Math . log10 (3.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('35', 0, StatorBottom); position = next;
	next = Math . log10 (3.6); ctx . rotate (pi2 * (next - position));
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('6:00', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (3.75); ctx . rotate (pi2 * (next - position)); ctx . fillText ('STAT.', 0, StatorBottom); position = next;
	next = Math . log10 (4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('40', 0, StatorBottom); position = next;
	next = Math . log10 (4.2); ctx . rotate (pi2 * (next - position));
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('7:00', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (4.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('45', 0, StatorBottom); position = next;
	next = Math . log10 (4.8); ctx . rotate (pi2 * (next - position));
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('8:00', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('50', 0, StatorBottom); position = next;
	next = Math . log10 (5.4); ctx . rotate (pi2 * (next - position));
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('9:00', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (5.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('55', 0, StatorBottom); position = next;
	//next = Math . log10 (6); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'red'; ctx . fillText ('60', 0, StatorBottom); position = next;
	//next = Math . log10 (6.5); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'white'; ctx . fillText ('65', 0, StatorBottom); position = next;
	next = Math . log10 (6.2); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'red'; ctx . fillText ('KM', 0, StatorBottom); position = next;
	next = Math . log10 (7); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = maker . StatorColour || 'white'; ctx . fillText ('7', 0, StatorBottom);
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('1:10', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('8', 0, StatorBottom);
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('1:20', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	next = Math . log10 (9); ctx . rotate (pi2 * (next - position)); ctx . fillText ('9', 0, StatorBottom);
		ctx . fillStyle = maker . ConvertersColour || 'white'; ctx . fillText ('1:30', 0, Converters); position = next; ctx . fillStyle = maker . StatorColour || 'white';
	ctx . restore ();
	//==== CONVERTERS ======================
	ctx . save ();
	ctx . fillStyle = maker . ConvertersColour || 'white';
	ctx . beginPath ();
	ctx . moveTo (0, - StatorTop);
	r1 = size * 0.025; r2 = Converters * 0.88;
	ctx . bezierCurveTo (0, Converters * 0.5 - StatorTop * 0.5, r1 * 0.5, Converters, r1, Converters);
	ctx . lineTo (- r1, Converters);
	ctx . bezierCurveTo (r1 * -0.5, Converters, 0, Converters * 0.5 - StatorTop * 0.5, 0, - StatorTop);
	ctx . fill ();
	if (maker . StatorColour) {ctx . strokeStyle = maker . StatorColour; ctx . stroke ();}
	ctx . fillText ('MPH', 0, Converters * 0.895);
	ctx . beginPath ();
	r1 = size * 0.042;
	ctx . moveTo (- r1, Converters);
	ctx . lineTo (- r1, r2); ctx . lineTo (r1, r2); ctx . lineTo (r1, Converters);
	ctx . strokeStyle = maker . ConvertersColour || 'white'; ctx . lineWidth = 3; ctx . stroke ();
	ctx . rotate (pi2 * - shift);
	ctx . strokeStyle = maker . ConvertersColour || 'white';
	ctx . beginPath ();
	r1 = MinuteConversionLine; r2 = MinuteConversionLine * 0.98; r3 = MinuteConversionLine * 0.96;
	for (var ind = 6; ind < 12; ind += 0.5) mark (ind, r1, r2);
	for (var ind = 12; ind < 30; ind ++) mark (ind, r1, r2);
	for (var ind = 30; ind < 60; ind += 6) {
		mark (ind, r1, r2); mark (ind + 1, r1, r2); mark (ind + 2, r1, r2);
		mark (ind + 3, r1, r3); mark (ind + 4, r1, r2); mark (ind + 5, r1, r2);
	}
	mark (6, r1, r3);
	ctx . stroke ();
	ctx . restore ();
	//==== CYFERBLAT MARKINGS ======================
	ctx . save ();
	r1 = Converters * -0.98; r2 = Converters * -0.95; r3 = Converters * -0.92; r4 = Converters * -0.88;
	ctx . beginPath ();
	for (var ind = 0; ind < 12; ind ++) {
		for (var sub = 0; sub < 0.98; sub += 0.2) {
			if (sub > 0) {var tick = ind + sub; if (tick >= 0.35 && tick <= 11.65) lmark ((ind + sub) / 12, r1, r3);}
			for (var esc = 0.05; esc < 0.2; esc += 0.05) {var tick = ind + sub + esc; if (tick >= 0.35 && tick <= 11.65) lmark (tick / 12, r1, r2);}
		}
	}
	ctx . strokeStyle = maker . CyferblatColour || 'white'; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 1; ind < 24; ind += 2) lmark (ind / 24, r2 - 1, r4);
	ctx . strokeStyle = maker . StrokeNumbers || 'lime'; ctx . lineWidth = size * 0.01; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 2; ind < 24; ind += 2) lmark (ind / 24, r1, r2);
	ctx . lineWidth = size * 0.004; ctx . stroke ();
	ctx . restore ();
	//==== BREITLING LOGO ======================
	ctx . save ();
	var LogoScaling = maker . LogoScaling * size;
	var logo = maker . Logo;
	ctx . scale (LogoScaling, LogoScaling);
	ctx . translate (logo . width * -0.5, size * -0.19 / LogoScaling);
	ctx . drawImage (logo, 0, 0);
	ctx . restore ();
	//==== WATCH MODEL ======================
	ctx . save ();
	ctx . fillStyle = maker . CyferblatColour || 'white';
	ctx . font = `${NumberSize2 * (maker . FontSize || 1)}px ${maker . Font || 'arial'}`;
	ctx . fillText (maker . LogoName, 0, size * -0.06); ctx . fillText (maker . LogoYear, 0, size * -0.035);
	ctx . fillText (maker . ModelName || 'NAVITIMER', 0, size * 0.06);
	ctx . restore ();
	//==== HOUR NUMBERS ======================
	ctx . save ();
	ctx . font = `bold ${HoursSize * (maker . FontSize || 1)}px ${maker . Font || 'arial'}`; ctx . textBaseline = 'middle'; ctx . textAlign = 'center';
	ctx . fillStyle = maker . FillNumbers || 'lime';
	ctx . strokeStyle = maker . StrokeNumbers || 'white';
	ctx . lineWidth = 2;
	for (var ind = 2; ind <= 24; ind += 2) {
		var tx = HoursRadius * Math . sin (Math . PI * ind / 12);
		var ty = HoursRadius * - Math . cos (Math . PI * ind / 12);
		ctx . fillText (ind, tx, ty);
		if (maker . StrokeNumbers) ctx . strokeText (ind, tx, ty);
	};
	ctx . restore ();
	//==== STATOR RED ARROWS ======================
	var t1 = - StatorTop + 1; t2 = StatorTop * -0.94; t3 = StatorTop * -0.89;
	ctx . save ();
	ctx . rotate (- pi2 * shift);
	ctx . beginPath ();
	ctx . moveTo (0, t1); ctx . lineTo (s6, t2); ctx . lineTo (- s6, t2); ctx . closePath ();
	ctx . fillStyle = 'red'; ctx . fill ();
	ctx . rotate (pi2 * Math . log10 (3.6));
	ctx . beginPath ();
	ctx . moveTo (0, t1); ctx . lineTo (s6, t2); ctx . lineTo (- s6, t2); ctx . closePath ();
	ctx . fill ();
	ctx . rotate (pi2 * (Math . log10 (3.3) - Math . log10 (3.6)));
	ctx . beginPath ();
	ctx . moveTo (0, t1); ctx . lineTo (s6, t2); ctx . lineTo (- s6, t2); ctx . closePath ();
	ctx . fill ();
	if (maker . AccurateConversions) ctx . rotate (pi2 * Math . log10 (1.15078));
	else ctx . rotate (pi2 * (Math . log10 (3.8) - Math . log10 (3.3)));
	ctx . beginPath ();
	ctx . moveTo (0, t1); ctx . lineTo (s6, t2); ctx . lineTo (- s6, t2); ctx . closePath ();
	ctx . fill ();
	if (maker . AccurateConversions) ctx . rotate (pi2 * (Math . log10 (1.852) - Math . log10 (1.15078)));
	else ctx . rotate (pi2 * (Math . log10 (6.1) - Math . log10 (3.8)));
	ctx . beginPath ();
	ctx . moveTo (0, t1); ctx . lineTo (s6, t2); ctx . lineTo (- s6, t2); ctx . closePath ();
	ctx . fill ();
	ctx . restore ();
	//==== MINUTE TOTALIZER ================
	var TotalizerRadius = maker . TotalizerRadius * size;
	var TotalizerBezel = maker . TotalizerBezel * size;
	var TotalizerStator = maker . TotalizerStator * size;
	var r1 = maker . TotalizerR1 * size; var r2 = maker . TotalizerR2 * size; var r3 = maker . TotalizerR3 * size;
	ctx . save ();
	ctx . translate (TotalizerRadius, 0);
	ctx . beginPath ();
	ctx . arc (0, 0, TotalizerBezel, 0, pi2);
	ctx . fillStyle = maker . TotalizerBezelColour; ctx . fill (); ctx . strokeStyle = maker . TotalizerRimColour; ctx . stroke ();
	ctx . beginPath ();
	ctx . arc (0, 0, TotalizerStator, 0, pi2);
	ctx . fillStyle = maker . TotalizerCyferblatColour; ctx . fill (); ctx . strokeStyle = maker . TotalizerStatorColour; ctx . stroke ();
	ctx . beginPath ();
	ctx . strokeStyle = maker . TotalizerMarkingsColour;
	for (var ind = 0; ind < 30; ind += 5)
		for (var sub = 1; sub < 5; sub ++)
			lmark ((ind + sub) / 30, r1, r2);
	ctx . stroke ();
	var lw = ctx . lineWidth; ctx . beginPath (); for (var ind = 0; ind < 6; ind ++) lmark (ind / 6, r1, r3); ctx . lineWidth = 2; ctx . stroke ();
	ctx . beginPath ();
	r1 = maker . TotalizerNumbers * size; r2 = r1 * Math . cos (Math . PI * 2 / 3); r3 = r1 * Math . sin (Math . PI * 2 / 3);
	ctx . fillStyle = maker . TotalizerMarkingsColour; ctx . textBaseline = 'middle';
	ctx . fillText (30, 0, - r1);
	ctx . fillText (10, r3, - r2);
	ctx . fillText (20, -r3, - r2);
	var ar1 = maker . TotalizerArrow1 * size;
	var ar2 = maker . TotalizerArrow2 * size;
	var ar3 = maker . TotalizerArrow3 * size;
	var ar4 = maker . TotalizerArrow4 * size;
	var ar5 = maker . TotalizerArrow5 * size;
	var ar6 = maker . TotalizerArrow6 * size;
	var ar7 = maker . TotalizerArrow7 * size;
	r1 = Math . asin (ar2 / ar4);
	if (Chronograph . From === null) ctx . rotate (Math . PI * -0.5);
	else {
		if (Chronograph . To === null) ctx . rotate (Math . PI * (-0.5 + (((DateNumber - Chronograph . From) % 1800000) / 900000)));
		else ctx . rotate (Math . PI * (-0.5 + (((Chronograph . To - Chronograph . From) % 1800000) / 900000)));
	}
	ctx . lineWidth = maker . TotalizerArrowBorderWidth;
	if (maker . TotalizerArrowNoButt) {
		ctx . beginPath (); ctx . arc (0, 0, ar4, r1, pi2 - r1);
		ctx . lineTo (ar7, - ar3); ctx . lineTo (TotalizerStator, 0); ctx . lineTo (ar7, ar3); ctx . closePath ();
		ctx . fillStyle = maker . TotalizerArrowColour; ctx . fill (); if (maker . TotalizerArrowBorderColour) {ctx . strokeStyle = maker . TotalizerArrowBorderColour; ctx . stroke ();}
	} else {
		ctx . beginPath (); ctx . arc (0, 0, ar4, r1, pi2 - r1);
		ctx . lineTo (ar5, - ar3); ctx . lineTo (ar7, - ar3); ctx . lineTo (TotalizerStator, 0);
		ctx . lineTo (ar7, ar3); ctx . lineTo (ar5, ar3); ctx . closePath ();
		ctx . fillStyle = maker . TotalizerArrowColour; ctx . fill (); if (maker . TotalizerArrowBorderColour) {ctx . strokeStyle = maker . TotalizerArrowBorderColour; ctx . stroke ();}
		ctx . beginPath ();
		ctx . arc (0, 0, ar4, r1, Math . PI - r1);
		ctx . lineTo (- ar6, ar2); ctx . lineTo (- ar6, - ar2);
		ctx . arc (0, 0, ar4, Math . PI + r1, pi2 - r1);
		ctx . fillStyle = maker . TotalizerArrowEndColour; ctx . fill (); ctx . stroke ();
	}
	ctx . beginPath (); ctx . arc (0, 0, ar1, 0, pi2); ctx . fillStyle = maker . PinColour; ctx . fill ();
	ctx . restore ();
	//==== HOUR TOTALIZER ================
	var TotalizerRadius = maker . TotalizerRadius * size;
	var TotalizerBezel = maker . TotalizerBezel * size;
	var TotalizerStator = maker . TotalizerStator * size;
	var r1 = maker . TotalizerR1 * size; var r2 = maker . TotalizerR2 * size; var r3 = maker . TotalizerR3 * size;
	ctx . save ();
	ctx . translate (0, Math . abs (TotalizerRadius));
	ctx . beginPath ();
	ctx . arc (0, 0, TotalizerBezel, 0, pi2);
	ctx . fillStyle = maker . TotalizerBezelColour; ctx . fill (); ctx . strokeStyle = maker . TotalizerRimColour; ctx . stroke ();
	ctx . beginPath ();
	ctx . arc (0, 0, TotalizerStator, 0, pi2);
	ctx . fillStyle = maker . TotalizerCyferblatColour; ctx . fill (); ctx . strokeStyle = maker . TotalizerStatorColour; ctx . stroke ();
	ctx . beginPath ();
	ctx . strokeStyle = maker . TotalizerMarkingsColour;
	for (var ind = 1; ind < 24; ind += 2) lmark (ind / 24, r1, r2);
	ctx . stroke ();
	var lw = ctx . lineWidth; ctx . beginPath (); for (var ind = 0; ind < 12; ind ++) lmark (ind / 12, r1, r3); ctx . lineWidth = 2; ctx . stroke ();
	ctx . beginPath ();
	r1 = maker . TotalizerNumbersH * size;
	ctx . fillStyle = maker . TotalizerMarkingsColour; ctx . textBaseline = 'middle';
	ctx . fillText (12, 0, - r1);
	ctx . fillText (3, r1, 0);
	ctx . fillText (6, 0, r1);
	ctx . fillText (9, - r1, 0);
	var ar1 = maker . TotalizerArrow1 * size;
	var ar2 = maker . TotalizerArrow2 * size;
	var ar3 = maker . TotalizerArrow3 * size;
	var ar4 = maker . TotalizerArrow4 * size;
	var ar5 = maker . TotalizerArrow5 * size;
	var ar6 = maker . TotalizerArrow6 * size;
	var ar7 = maker . TotalizerArrow7 * size;
	r1 = Math . asin (ar2 / ar4);
	if (Chronograph . From === null) ctx . rotate (Math . PI * -0.5);
	else {
		if (Chronograph . To === null) ctx . rotate (Math . PI * (-0.5 + (((DateNumber - Chronograph . From) % 43200000) / 21600000)));
		else ctx . rotate (Math . PI * (-0.5 + (((Chronograph . To - Chronograph . From) % 43200000) / 21600000)));
	}
	ctx . lineWidth = maker . TotalizerArrowBorderWidth;
	if (maker . TotalizerArrowNoButt) {
		ctx . beginPath (); ctx . arc (0, 0, ar4, r1, pi2 - r1);
		ctx . lineTo (ar7, - ar3); ctx . lineTo (TotalizerStator, 0); ctx . lineTo (ar7, ar3); ctx . closePath ();
		ctx . fillStyle = maker . TotalizerArrowColour; ctx . fill (); if (maker . TotalizerArrowBorderColour) {ctx . strokeStyle = maker . TotalizerArrowBorderColour; ctx . stroke ();}
	} else {
		ctx . beginPath (); ctx . arc (0, 0, ar4, r1, pi2 - r1);
		ctx . lineTo (ar5, - ar3); ctx . lineTo (ar7, - ar3); ctx . lineTo (TotalizerStator, 0);
		ctx . lineTo (ar7, ar3); ctx . lineTo (ar5, ar3); ctx . closePath ();
		ctx . fillStyle = maker . TotalizerArrowColour; ctx . fill (); if (maker . TotalizerArrowBorderColour) {ctx . strokeStyle = maker . TotalizerArrowBorderColour; ctx . stroke ();}
		ctx . beginPath ();
		ctx . arc (0, 0, ar4, r1, Math . PI - r1);
		ctx . lineTo (- ar6, ar2); ctx . lineTo (- ar6, - ar2);
		ctx . arc (0, 0, ar4, Math . PI + r1, pi2 - r1);
		ctx . fillStyle = maker . TotalizerArrowEndColour; ctx . fill (); ctx . stroke ();
	}
	ctx . beginPath (); ctx . arc (0, 0, ar1, 0, pi2); ctx . fillStyle = maker . PinColour; ctx . fill ();
	ctx . restore ();
	//==== SECONDS HAND ================
	var TotalizerRadius = maker . TotalizerRadius * size;
	var TotalizerBezel = maker . TotalizerBezel * size;
	var TotalizerStator = maker . TotalizerStator * size;
	var r1 = maker . TotalizerR1 * size; var r2 = maker . TotalizerR2 * size; var r3 = maker . TotalizerR3 * size;
	ctx . save ();
	ctx . translate (- TotalizerRadius, 0);
	ctx . beginPath ();
	ctx . arc (0, 0, TotalizerBezel, 0, pi2);
	ctx . fillStyle = maker . TotalizerBezelColour; ctx . fill (); ctx . strokeStyle = maker . TotalizerRimColour; ctx . stroke ();
	ctx . beginPath ();
	ctx . arc (0, 0, TotalizerStator, 0, pi2);
	ctx . fillStyle = maker . TotalizerCyferblatColour; ctx . fill (); ctx . strokeStyle = maker . TotalizerStatorColour; ctx . stroke ();
	ctx . beginPath ();
	ctx . strokeStyle = maker . TotalizerMarkingsColour;
	for (var ind = 0; ind < 12; ind += 4)
		for (var sub = 1; sub < 4; sub ++)
			lmark ((ind + sub) / 12, r1, r2);
	if (maker . TotalizerR4) {
		var r4 = maker . TotalizerR4 * size;
		for (var ind = 0; ind < 60; ind += 5)
			for (var sub = 1; sub < 5; sub ++)
				lmark ((ind + sub) / 60, r1, r4);
	}
	ctx . stroke ();
	var lw = ctx . lineWidth; ctx . beginPath (); for (var ind = 0; ind < 3; ind ++) lmark (ind / 3, r1, r3); ctx . lineWidth = 2; ctx . stroke ();
	ctx . beginPath ();
	r1 = maker . TotalizerNumbers * size; r2 = r1 * Math . cos (Math . PI * 2 / 3); r3 = r1 * Math . sin (Math . PI * 2 / 3);
	ctx . fillStyle = maker . TotalizerMarkingsColour; ctx . textBaseline = 'middle';
	ctx . fillText (60, 0, - r1);
	ctx . fillText (20, r3, - r2);
	ctx . fillText (40, -r3, - r2);
	var ar1 = maker . TotalizerArrow1 * size;
	var ar2 = maker . TotalizerArrow2 * size;
	var ar3 = maker . TotalizerArrow3 * size;
	var ar4 = maker . TotalizerArrow4 * size;
	var ar5 = maker . TotalizerArrow5 * size;
	var ar6 = maker . TotalizerArrow6 * size;
	var ar7 = maker . TotalizerArrow7 * size;
	r1 = Math . asin (ar2 / ar4);
	ctx . rotate ((date . getSeconds () + date . getMilliseconds () / 1000) * Math . PI / 30 - Math . PI * 0.5);
	ctx . lineWidth = maker . TotalizerArrowBorderWidth;
	if (maker . TotalizerArrowNoButt) {
		ctx . beginPath (); ctx . arc (0, 0, ar4, r1, pi2 - r1);
		ctx . lineTo (ar7, - ar3); ctx . lineTo (TotalizerStator, 0); ctx . lineTo (ar7, ar3); ctx . closePath ();
		ctx . fillStyle = maker . TotalizerArrowColour; ctx . fill (); if (maker . TotalizerArrowBorderColour) {ctx . strokeStyle = maker . TotalizerArrowBorderColour; ctx . stroke ();}
	} else {
		ctx . beginPath (); ctx . arc (0, 0, ar4, r1, pi2 - r1);
		ctx . lineTo (ar5, - ar3); ctx . lineTo (ar7, - ar3); ctx . lineTo (TotalizerStator, 0);
		ctx . lineTo (ar7, ar3); ctx . lineTo (ar5, ar3); ctx . closePath ();
		ctx . fillStyle = maker . TotalizerArrowColour; ctx . fill (); if (maker . TotalizerArrowBorderColour) {ctx . strokeStyle = maker . TotalizerArrowBorderColour; ctx . stroke ();}
		ctx . beginPath ();
		ctx . arc (0, 0, ar4, r1, Math . PI - r1);
		ctx . lineTo (- ar6, ar2); ctx . lineTo (- ar6, - ar2);
		ctx . arc (0, 0, ar4, Math . PI + r1, pi2 - r1);
		ctx . fillStyle = maker . TotalizerArrowEndColour; ctx . fill (); ctx . stroke ();
	}
	ctx . beginPath (); ctx . arc (0, 0, ar1, 0, pi2); ctx . fillStyle = maker . PinColour; ctx . fill ();
	ctx . restore ();
	//==== DATE DISPLAY =======================
	ctx . save ();
	ctx . rotate (0.125 * pi2);
	ctx . beginPath ();
	var rct = {x: HoursRadius, y: 0, w1: HoursSize * 0.6, h1: HoursSize * 0.5, w2: HoursSize * 0.7, h2: HoursSize * 0.6};
	ctx . moveTo (rct . x - rct . w2, - rct . h2); ctx . lineTo (rct . x + rct . w2, - rct . h2); ctx . lineTo (rct . x + rct . w2, rct . h2); ctx . lineTo (rct . x - rct . w2, rct . h2);
	ctx . lineTo (rct . x - rct . w2, - rct . h2); ctx . fillStyle = maker . DateDisplayBorderColour || 'black'; ctx . fill ();
	ctx . lineTo (rct . x - rct . w1, - rct . h1);
	ctx . moveTo (rct . x + rct . w2, - rct . h2); ctx . lineTo (rct . x + rct . w1, - rct . h1);
	ctx . moveTo (rct . x + rct . w2, rct . h2); ctx . lineTo (rct . x + rct . w1, rct . h1);
	ctx . moveTo (rct . x - rct . w2, rct . h2); ctx . lineTo (rct . x - rct . w1, rct . h1);
	ctx . strokeStyle = 'white'; ctx . stroke ();
	ctx . beginPath (); ctx . moveTo (rct . x - rct . w1, - rct . h1);
	ctx . lineTo (rct . x + rct . w1, - rct . h1); ctx . lineTo (rct . x + rct . w1, rct . h1); ctx . lineTo (rct . x - rct . w1, rct . h1); ctx . closePath ();
	ctx . fillStyle = maker . DateDisplayBackground || 'navy'; ctx . fill (); ctx . stroke ();
	ctx . font = `${HoursSize * (maker . FontSize || 1)}px ${maker . Font || 'serif'}`;
	ctx . fillStyle = maker . DateDisplayColour || 'white'; ctx . textBaseline = 'middle'; ctx . textAlign = 'center'; ctx . fillText (Day, rct . x, rct . y);
	ctx . restore ();
	//==== HOUR HAND ======================
	ctx . save ();
	var ss6 = size * 0.006;
	ctx . rotate ((date . getHours () + date . getMinutes () / 60 + date . getSeconds () / 3600) * Math . PI / 12 - Math . PI * 0.5);
	ctx . beginPath ();
	ctx . arc (0, 0, size * 0.02, 0.25, Math . PI * 2 - 0.25);
	ctx . lineTo (size * 0.034, size * -0.01);
	ctx . lineTo (size * 0.15, size * -0.01);
	ctx . lineTo (size * 0.17, 0);
	ctx . lineTo (size * 0.15, size * 0.01);
	ctx . lineTo (size * 0.034, size * 0.01);
	ctx . closePath ();
	ctx . fillStyle = maker . HandBackground || 'silver';
	ctx . fill ();
	ctx . strokeStyle = maker . HandStroke || 'black';
	ctx . stroke ();
	ctx . beginPath ();
	ctx . fillStyle = maker . HandLining || 'lime';
	ctx . moveTo (size * 0.04, - ss6);
	ctx . lineTo (size * 0.14, - ss6);
	ctx . lineTo (size * 0.15, 0);
	ctx . lineTo (size * 0.14, ss6);
	ctx . lineTo (size * 0.04, ss6);
	ctx . fill ();
	ctx . restore ();
	//==== MINUTE HAND ======================
	ctx . save ();
	ctx . rotate ((date . getMinutes () + date . getSeconds () / 60 + date . getMilliseconds () / 60000) * Math . PI / 30 - Math . PI * 0.5);
	ctx . beginPath ();
	ctx . arc (0, 0, size * 0.016, 0.25, Math . PI * 2 - 0.25);
	r1 = Converters * -0.84; r2 = Converters * -0.91;
	r3 = Converters * -0.81; r4 = Converters * -0.83;
	ctx . lineTo (size * 0.034, size * -0.01);
	ctx . lineTo (r1, size * -0.01);
	ctx . lineTo (r2, 0);
	ctx . lineTo (r1, size * 0.01);
	ctx . lineTo (size * 0.034, size * 0.01);
	ctx . closePath ();
	ctx . fillStyle = maker . HandBackground || 'silver'; ctx . fill (); ctx . strokeStyle = maker . HandStroke || 'black'; ctx . stroke ();
	ctx . beginPath ();
	ctx . fillStyle = maker . HandLining || 'lime';
	ctx . moveTo (size * 0.04, - ss6);
	ctx . lineTo (r3, - ss6);
	ctx . lineTo (r4, 0);
	ctx . lineTo (r3, ss6);
	ctx . lineTo (size * 0.04, ss6);
	ctx . fill ();
	ctx . restore ();
	//==== CHRONOGRAPH SECONDS TOTALIZER ================
	ctx . save ();
	var ss4 = size * 0.004;
	if (Chronograph . From === null) ctx . rotate (Math . PI * -0.5);
	else {
		if (Chronograph . To === null) ctx . rotate (Math . PI * (-0.5 + (((DateNumber - Chronograph . From) % 60000) / 30000)));
		else ctx . rotate (Math . PI * (-0.5 + (((Chronograph . To - Chronograph . From) % 60000) / 30000)));
	}
	r1 = Converters * -0.76; r2 = Converters * -0.78; r3 = Converters * -0.93; r4 = size * 0.02;
	ctx . beginPath ();
	ctx . moveTo (0, - ss4); ctx . lineTo (r2, - ss4); ctx . lineTo (r1, - r4);
	ctx . bezierCurveTo (Converters * -0.8, size * -0.012, Converters * -0.89, 0, r3, 0);
	ctx . bezierCurveTo (Converters * -0.89, 0, Converters * -0.8, size * 0.012, r1, r4);
	ctx . lineTo (r2, ss4);
	ctx . lineTo (0, ss4);
	ctx . closePath ();
	ctx . fillStyle = 'red'; ctx . fill (); ctx . strokeStyle = 'red'; ctx . stroke ();
	ctx . beginPath ();
	r1 = size * 0.012;
	r2 = Math . asin (ss4 / r1);
	ctx . arc (0, 0, r1, r2, Math . PI * 2 - r2);
	ctx . fillStyle = 'silver'; ctx . fill (); ctx . strokeStyle = 'black'; ctx . stroke ();
	ctx . beginPath (); ctx . arc (0, 0, ar1, 0, pi2); ctx . fillStyle = maker . PinColour; ctx . fill ();
	ctx . restore ();
	//==== CURSOR ======================
	if (CursorVisible) {
		ctx . save ();
		ctx . strokeStyle = 'red';
		ctx . beginPath (); lmark (Cursor, - BezelRadius, HoursRadius); ctx . strokeStyle = 'red'; ctx . stroke ();
		var BezelText = Math . pow (10, Cursor - degree + Math . log10 (0.6));
		while (BezelText >= 100) BezelText /= 10; while (BezelText < 10) BezelText *= 10;
		var sin = Math . sin (Cursor * pi2); var cos = Math . cos (Cursor * pi2);
		var centre = {x: - BezelRadius * sin, y: BezelRadius * cos, width: NumberSize1 * 2, height: NumberSize1 * 0.7};
		ctx . beginPath ();
		ctx . moveTo (centre . x - centre . width, centre . y - centre . height);
		ctx . lineTo (centre . x + centre . width, centre . y - centre . height);
		ctx . lineTo (centre . x + centre . width, centre . y + centre . height);
		ctx . lineTo (centre . x - centre . width, centre . y + centre . height); ctx . closePath ();
		centre . x = HoursRadius * sin; centre . y = - HoursRadius * cos; centre . height = NumberSize1 * 1.25;
		ctx . moveTo (centre . x - centre . width, centre . y - centre . height);
		ctx . lineTo (centre . x + centre . width, centre . y - centre . height);
		ctx . lineTo (centre . x + centre . width, centre . y + centre . height);
		ctx . lineTo (centre . x - centre . width, centre . y + centre . height); ctx . closePath ();
		ctx . fillStyle = 'black'; ctx . fill ();
		ctx . strokeStyle = 'red'; ctx . stroke ();
		ctx . font = `bold ${NumberSize1}px georgia`;
		ctx . fillStyle = 'red'; ctx . textBaseline = 'middle'; ctx . fillText (BezelText . toFixed (2), - BezelRadius * sin, BezelRadius * cos);
		var StatorText = Math . pow (10, Cursor + Math . log10 (0.6));
		while (StatorText >= 100) StatorText /= 10; while (StatorText < 10) StatorText *= 10;
		var ConverterText = StatorText; if (ConverterText < 60) ConverterText *= 10;
		ConverterText /= 60;
		ConverterMinutes = Math . round ((ConverterText % 1) * 60) . toString ();
		if (ConverterMinutes . length < 2) ConverterMinutes = 0 + ConverterMinutes;
		ConverterText = `( ${Math . floor (ConverterText)}:${ConverterMinutes} )`;
		ctx . textBaseline = 'bottom'; ctx . fillText (StatorText . toFixed (2), HoursRadius * sin, - HoursRadius * cos);
		ctx . textBaseline = 'top'; ctx . fillText (ConverterText, HoursRadius * sin, - HoursRadius * cos);
		ctx . restore ();
	}
	//======================
	ctx . restore ();
};

var HiRes = function () {clearInterval (Interval); Interval = setInterval (repaint, 20);};
var LoRes = function () {clearInterval (Interval); Interval = setInterval (repaint, 250);};

Interval = setInterval (repaint, 250);

</script>


</body>

</html>
